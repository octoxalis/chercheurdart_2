
const STAT_W_o={port_o:null,status_o:{scan_b:!1},scan_a:null,client_o:{},sleep__v:_=>new Promise((s=>setTimeout(s,_))),read__v(_,s,o="text"){fetch(_).then((_=>{if(_.ok)return _[o]();throw new Error(`${_.status}: ${_.statusText}`)})).then((_=>{s(_)})).catch((_=>console.error(_)))},get_scan__v(_){STAT_W_o.read__v(`/assets/media/img/${_.work_s}/full/max/0/scan.json`,(_=>{STAT_W_o.scan_a=new Function(`return ${_}`)(),STAT_W_o.scan_a&&(STAT_W_o.status_o.scan_b=!0),console.timeEnd("scan")}
//!!!!!!!!!!!!!!!!!!!!!!!!!!
))},get_status__v(){STAT_W_o.post__v({task_s:"PUT_status",status_o:STAT_W_o.status_o},[STAT_W_o.status_o])},put_offCanvas__v(_){const s=_.client_s;STAT_W_o.client_o[s]||(STAT_W_o.client_o[s]={}),STAT_W_o.client_o[s].offCanvas_e=_.offCanvas_e,STAT_W_o.client_o[s].context_o=_.offCanvas_e.getContext("2d")},async put_draw_test(_){let s=100;
//!!!!!!!!!!!!!!!!!!!!!!!!!!
for(console.time("sleep");!STAT_W_o.status_o.scan_b;){if(!(--s>0)){STAT_W_o.post__v({client_s:_.client_s,task_s:"PUT_error",error_s:"scan is not available"});break}await STAT_W_o.sleep__v(50)}
//!!!!!!!!!!!!!!!!!!!!!!!!!!
console.timeEnd("sleep"),
//!!!!!!!!!!!!!!!!!!!!!!!!!!
STAT_W_o.client_o[_.client_s].context_o.fillRect(100,200,400,300)},message__v(_){const s=_.data;switch(s.task_s){case"GET_scan":STAT_W_o.get_scan__v(s);break;case"GET_status":STAT_W_o.get_status__v();break;case"PUT_offCanvas":STAT_W_o.put_offCanvas__v(s);break;case"PUT_draw_test":STAT_W_o.put_draw_test(s)}},post__v(_){STAT_W_o.port_o.postMessage(_)},handleError__v:_=>console.log`ERROR: ${_.message}`};onconnect=_=>{console.time("scan"),
//!!!!!!!!!!!!!!!!!!!!!!!!!!
STAT_W_o.port_o=_.ports[0],STAT_W_o.port_o.onmessage=STAT_W_o.message__v,STAT_W_o.port_o.onmessageerror=STAT_W_o.handleError__v};